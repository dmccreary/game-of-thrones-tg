{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"about/","title":"About the Game of Thrones Demo","text":"<p>This is for doing simple demos of a social network.</p>"},{"location":"contact/","title":"Contact","text":"<p>Dan McCreary LinkedIn</p>"},{"location":"data-model/","title":"Customer 360 Data Model","text":"<p>Our data model is just a single vertex type called <code>Person</code> with a <code>RELATED</code> edge to itself (reflexive).</p> <p></p> <p></p>"},{"location":"explore-graph/","title":"Explore Graph","text":""},{"location":"getting-started/","title":"Getting Started","text":"<pre><code>brew install miniforge\n</code></pre>"},{"location":"getting-started/#sample-transcript","title":"Sample Transcript","text":"<pre><code>Transaction finished\n\nTo activate this environment, use:\n\n    micromamba activate /usr/local/Caskroom/miniforge/base\n\nOr to execute a single command in this environment, use:\n\n    micromamba run -p /usr/local/Caskroom/miniforge/base mycommand\n\ninstallation finished.\n==&gt; Linking Binary 'conda' to '/usr/local/bin/conda'\n==&gt; Linking Binary 'mamba' to '/usr/local/bin/mamba'\n\ud83c\udf7a  miniforge was successfully installed!\n</code></pre>"},{"location":"getting-started/#conda-init","title":"Conda Init","text":"<pre><code>conda init\n</code></pre>"},{"location":"healthcheck/","title":"Healthcheck","text":""},{"location":"healthcheck/#install-the-jq-command","title":"Install the \"jq\" command","text":"<p><code>jq</code> takes an input JSON stream and reformats it to have color syntax highlighting and indentation.</p> <pre><code>brew install jq\n</code></pre>"},{"location":"healthcheck/#shell-command-to-monitor-health","title":"Shell command to monitor health","text":"<pre><code>curl -s http://dans-macbook-pro.local:14240/api/ping | jq\n</code></pre>"},{"location":"healthcheck/#sample-response","title":"Sample Response","text":"<pre><code>{\n  \"error\": false,\n  \"message\": \"pong\",\n  \"results\": null\n}\n</code></pre>"},{"location":"healthcheck/#testing-builtin-endpoints","title":"Testing Builtin Endpoints","text":"<pre><code>curl -s http://dans-macbook-pro.local:9000/endpoints/got | jq\n</code></pre> <p>This will return about 2100 lines of JSON.</p>"},{"location":"healthcheck/#testing-specific-query","title":"Testing Specific Query","text":"<pre><code>curl -s http://dans-macbook-pro.local:14240/restpp/query/got/countPeople2 | jq\n</code></pre> <p>This returns:</p> <pre><code>{\n  \"version\": {\n    \"edition\": \"enterprise\",\n    \"api\": \"v2\",\n    \"schema\": 3\n  },\n  \"error\": false,\n  \"message\": \"\",\n  \"results\": [\n    {\n      \"Results.size()\": 187\n    }\n  ]\n}\n</code></pre>"},{"location":"load-data/","title":"Load Data","text":""},{"location":"load-data/#data-map","title":"Data Map","text":""},{"location":"load-data/#data-stats","title":"Data Stats","text":""},{"location":"references/","title":"References","text":"<ul> <li>Game of Thrones Datasets on Kaggle</li> </ul>"},{"location":"sample-data/","title":"Sample Game-of-Thrones Data","text":"<p>We found a sample Game of Thrones dataset on * Kaggle</p> <p>If two names were mentioned within 15 words a link count was created:</p> <pre><code>Source,Target,Type,weight,book\nAddam-Marbrand,Jaime-Lannister,Undirected,3,1\nAddam-Marbrand,Tywin-Lannister,Undirected,6,1\nAegon-I-Targaryen,Daenerys-Targaryen,Undirected,5,1\nAegon-I-Targaryen,Eddard-Stark,Undirected,4,1\nAemon-Targaryen-(Maester-Aemon),Alliser-Thorne,Undirected,4,1\n</code></pre> <p>We first want to create a list of vertices that include all the people's names, both Source and Target names should be included.</p>"},{"location":"sample-data/#loading-people","title":"Loading People","text":"<p>Although there are ways to do this with the GUI, I created a simple Python program that creates a single list of people.</p> <pre><code>import pandas as pd\n\n# Load the CSV file\nfile_path = '../data/book1.csv'\ndata = pd.read_csv(file_path)\n\n# Assuming the first two columns contain person names\nnames_col1 = data.iloc[:, 0].dropna().unique()\nnames_col2 = data.iloc[:, 1].dropna().unique()\n\n# Combine and get unique names\nunique_names = set(names_col1).union(set(names_col2))\nunique_names = sorted(unique_names)\n\n# Create a new DataFrame and save to CSV\nunique_names_df = pd.DataFrame(unique_names, columns=[\"Names\"])\noutput_path = '../data/book1-people.csv'\nunique_names_df.to_csv(output_path, index=False)\n\noutput_path\n</code></pre> <p>The people names file now looks like this:</p> <pre><code>Names\nAddam-Marbrand\nAegon-I-Targaryen\nAemon-Targaryen-(Maester-Aemon)\nAerys-II-Targaryen\nAggo\nAlbett\nAlliser-Thorne\nAlyn\n</code></pre> <p>This can then be loaded using the \"Load Data\" </p>"},{"location":"sample-queries/","title":"Sample Queries","text":""},{"location":"sample-queries/#count-the-number-of-person-verticies","title":"Count the number of Person Verticies","text":"<p>We will use the size() function:</p> <pre><code>CREATE DISTRIBUTED QUERY countPeople() FOR GRAPH got SYNTAX V1 {\n  # The seed is all Person verticies   \n  People = {Person.*};\n  # The size operator counts the number of entry points into the graph\n  PRINT People.size();\n}\n</code></pre> <p>We can also use a SELECT clause:</p> <pre><code>CREATE DISTRIBUTED QUERY countPeople() FOR GRAPH got Syntax V2{ \n  People = {Person.*};\n  Results = SELECT p FROM Peole:p;\n  PRINT Result.size();\n}\n</code></pre>"},{"location":"sample-queries/#results","title":"Results","text":"<pre><code>[\n  {\n    \"\\\"countPeople works!\\\"\": \"countPeople works!\"\n  },\n  {\n    \"R.size()\": 187\n  }\n]\n</code></pre>"},{"location":"sample-queries/#counting-the-number-of-edges","title":"Counting the Number of Edges","text":"<p>We can use an accumulator to count the number of edges in the graph.</p> <pre><code>CREATE DISTRIBUTED QUERY countEdges() FOR GRAPH got { \n  SumAccum&lt;INT&gt; @@edgeCount;\n\n  # Get all the vertices from ANY vertex Type\n  start = {ANY};\n  edgeCountQuery = SELECT s\n                   FROM start:s -(:e)- :d\n                   ACCUM @@edgeCount += 1;\n  # total edges is half since we are traversing each edge from the start to the destinaton\n  PRINT @@edgeCount/2;\n}\n</code></pre> <p>We kept a placeholder alias for the edge called <code>:e</code> and the desitination :d, but we could have left out the edge:</p> <pre><code>edgeCountQuery = SELECT s\n                FROM start:s -()- :d\n                ACCUM @@edgeCount += 1;\n</code></pre> <p>Response:</p> <p>Note that this works because there is only one edge type between people.</p>"},{"location":"sample-queries/#selecting-all-people","title":"Selecting All People","text":"<pre><code>CREATE DISTRIBUTED QUERY listNames(/* Parameters here */) FOR GRAPH got {\n  People = {Person.*};\n  Results = SELECT p FROM People:p;\n  PRINT Results;\n}\n</code></pre>"},{"location":"sample-queries/#selecting-the-most-popular-people","title":"Selecting the Most Popular People","text":""},{"location":"sample-queries/#outdegree-method","title":"Outdegree Method","text":"<p>We can use the <code>outdegree()</code> function to find the people with over 40 connections to other people.</p> <pre><code>/* main characters that have at over 40 connections */\nCREATE DISTRIBUTED QUERY personDegree() FOR GRAPH got { \n  start = {Person.*};\n  mainChars = \n    SELECT s\n    FROM start:s -(RELATED:e)- :t\n    WHERE s.outdegree() &gt; 40;\n  PRINT mainChars;\n}\n</code></pre> <p>You can also add a parameter to outdegree to indicate the relationship type <code>s.outdegree(RELATED)</code>.</p> <p>Result:</p> <pre><code>[\n  {\n    \"mainChars\": [\n      {\n        \"attributes\": {\n          \"id\": \"Eddard-Stark\",\n          \"name\": \"Eddard-Stark\"\n        },\n        \"v_id\": \"Eddard-Stark\",\n        \"v_type\": \"Person\"\n      },\n      {\n        \"attributes\": {\n          \"id\": \"Robert-Baratheon\",\n          \"name\": \"Robert-Baratheon\"\n        },\n        \"v_id\": \"Robert-Baratheon\",\n        \"v_type\": \"Person\"\n      },\n      {\n        \"attributes\": {\n          \"id\": \"Catelyn-Stark\",\n          \"name\": \"Catelyn-Stark\"\n        },\n        \"v_id\": \"Catelyn-Stark\",\n        \"v_type\": \"Person\"\n      },\n      {\n        \"attributes\": {\n          \"id\": \"Tyrion-Lannister\",\n          \"name\": \"Tyrion-Lannister\"\n        },\n        \"v_id\": \"Tyrion-Lannister\",\n        \"v_type\": \"Person\"\n      }\n    ]\n  }\n]\n</code></pre> <p>Expanding these nodes gives you the following:</p> <p></p> <p>You can now see the people that connect the characters.</p>"}]}